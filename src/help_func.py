import numpy as np
import matplotlib.pyplot as plt
import datetime
import os


def inverse_matrix_block_symetric(A, B, D, A_inv):
    # inverting a matrix with the block shape 
    # | A   B | 
    # | B^T C |
    # where A^-1 is already calculated

    n = A.shape[0]
    m = D.shape[0]
    inverted_matrix = np.zeros((n+m,n+m))

    U = B.T @ A_inv
    V = U.T 

    S = np.linalg.inv(D - B.T @ A_inv @ B)
    
    V_at_S = V @ S

    inverted_matrix[0:n,0:n] = A_inv + V_at_S @ U
    inverted_matrix[n:(n+m),0:n] = - S @ U
    inverted_matrix[0:n,n:(n+m)] = - V_at_S
    inverted_matrix[(n):(n+m),(n):(n+m)] = S
    return inverted_matrix

def prior_function(S: np.ndarray,T: np.ndarray) -> np.ndarray:
    beta_0 = 0.5 # The mean intensity
    beta_1 = 2 # The amplitude of the intensity
    beta_2 = 1 / 6**2 # related to the width of the intensity
    peak_depth_min = 10
    peak_depth_max = 60

    # The intesity function is dependant on the depth and time of day 
    phase = 2 * 3.1415926 * T /(24 * 3600)
    peak_depth = np.sin(phase) * (peak_depth_max - peak_depth_min) + peak_depth_min
    return np.exp(-(peak_depth - S)**2 * beta_2) * beta_1 + beta_0


def get_intensity_mu_x(S: np.ndarray,T: np.ndarray) -> np.ndarray:
    beta_0 = 0.5 # The mean intensity
    beta_1 = 2 # The amplitude of the intensity
    beta_2 = 1 / 6**2 # related to the width of the intensity
    peak_depth_min = 10
    peak_depth_max = 60

    Sz = S[:,2]

    # The intesity function is dependant on the depth and time of day 
    phase = 2 * 3.1415926 * T /(24 * 3600)
    peak_depth = np.sin(phase) * (peak_depth_max - peak_depth_min) + peak_depth_min
    return np.exp(-(peak_depth - Sz)**2 * beta_2) * beta_1 + beta_0


def get_possible_next_locations(s_now, t_now, diving_speed, sampling_frequency, s_lim):
    # Find the possible next locations
    next_smaple_time = 1 / sampling_frequency
    dive_range = [-diving_speed * 60, +diving_speed * 60]
    s_range = [s_now + dive_range[0], s_now + dive_range[1]]

    n_locations = 7

    # Make sure the range is within the limits
    s_range[0] = max(s_range[0], s_lim[0])
    s_range[1] = min(s_range[1], s_lim[1])
    # Find the possible next locations
    s_next = np.linspace(s_range[0], s_range[1],n_locations)
    t_next = np.repeat(t_now + 60, len(s_next)) 
    return s_next, t_next


def plot_timing(timing_dict):

    for key in timing_dict.keys():

        timing_dat = timing_dict[key]
        x = np.linspace(0,1, len(timing_dat["time_list"]))
        plt.plot(x, timing_dat["time_list"], label = key)

    plt.legend()
    plt.title("time per call for function")
    plt.ylabel("Time seconds")

    plt.savefig("figures/tests/Model/timing.png")
    plt.close()


    for key in timing_dict.keys():
        
        timing_dat = timing_dict[key]
        x = np.linspace(0,1, len(timing_dat["time_list"]))
        y = np.cumsum(timing_dat["time_list"])
        plt.plot(x, y, label = key)

    plt.legend()
    plt.title("Cumulative time for function")
    plt.ylabel("Time seconds")
    plt.savefig("figures/tests/Model/cumulative_timing.png")
    plt.close()


def sliding_average(x, window_size):
    return np.convolve(x, np.ones(window_size), 'valid') / window_size

def time_now_str():
    now = datetime.datetime.now()
    return now.strftime("%Y-%m-%d %H:%M:%S")

def id_now_str():
    now = datetime.datetime.now()
    return now.strftime("%Y%m%d_%H%M%S")


def get_get_experiment_id(folder: str):
     if experiment_id == "new":
        # Finding a new experiment id
        # Read all the files in the folder 
        files = os.listdir("src/save_counter_data/")
        print("[INFO] expermimenets in memory")
        # finding the file numbers
        file_numbers = []
        for file in files:
            file_id = file.split("_")[-1]
            if file_id.isdigit():
                file_numbers.append(int(file_id))
        #print(file_numbers)
        # Finding the lowest number that is not used
        for i in range(len(file_numbers) + 1):
            if i not in file_numbers:
                experiment_id = i
                break
        print("[INFO] Experiment id: ", experiment_id)



def generate_samples(mu, sigma, m=1):
    # Generate samples from a multivariate normal distribution
    # with mean mu and covariance sigma
    # The samples are generated by first generating samples from a standard normal distribution
    # and then transforming them to the correct distribution
    n = mu.shape[0]
    L = np.linalg.cholesky(sigma)

    samples = np.zeros((m,n))

    if m == 1:
        # Generate samples from a standard normal distribution
        z = np.random.normal(0, 1, n)
        # Transform the samples to the correct distribution
        x = mu + L @ z
        return x

    for i in range(m):
        # Generate samples from a standard normal distribution
        z = np.random.normal(0, 1, n)
        # Transform the samples to the correct distribution
        
        x = mu + L @ z
        samples[i,:] = x
    return samples



if __name__ == "__main__":
    # Test the function
    print(id_now_str())